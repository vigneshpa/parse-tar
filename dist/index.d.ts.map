{"mappings":"AAAA,iCACE,OAAO,EAAE,IAAI,GACZ,OAAO,CAAC,QAAQ,CAAC,QAAQ,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;AACtC,iCACE,OAAO,EAAE,WAAW,GAAG,eAAe,GACrC,QAAQ,CAAC,QAAQ,UAAU,CAAC,CAAC,EAAE,CAAC;AAyDnC,OAAO,KAAK;IACV,UAAU,IAAI;IACd,QAAQ,IAAI;IACZ,YAAY,IAAI;IAChB,gBAAgB,IAAI;IACpB,YAAY,IAAI;IAChB,SAAS,IAAI;IACb,aAAa,IAAI;IACjB,cAAc,IAAI;IAClB,MAAM,WAAW;CAClB;AACD,qBAAqB,CAAC,SAAS,IAAI,GAAG,UAAU;IAC9C,IAAI,EAAE,MAAM,CAAM;IAClB,IAAI,EAAE,MAAM,CAAK;IACjB,GAAG,EAAE,MAAM,CAAK;IAChB,GAAG,EAAE,MAAM,CAAK;IAChB,IAAI,EAAE,MAAM,CAAK;IACjB,KAAK,EAAE,IAAI,CAAe;IAC1B,IAAI,EAAE,WAAW,CAA0B;IAC3C,QAAQ,EAAE,MAAM,CAAM;IACtB,QAAQ,CAAC,EAAE,CAAC,CAAC;IACb,KAAK,EAAE,MAAM,CAAM;IACnB,KAAK,EAAE,MAAM,CAAM;IACnB,WAAW,EAAE,MAAM,CAAK;IACxB,WAAW,EAAE,MAAM,CAAK;IACxB,cAAc,EAAE,MAAM,CAAM;CAC7B","sources":["src/src/parseTar.ts","src/parseTar.ts"],"sourcesContent":[null,"export default function parseTar(\n  tarfile: Blob\n): Promise<Readonly<TarFile<Blob>>[]>;\nexport default function parseTar(\n  tarfile: ArrayBuffer | ArrayBufferLike\n): Readonly<TarFile<Uint8Array>>[];\nexport default function parseTar(\n  tarfile: Blob | ArrayBuffer | ArrayBufferLike\n) {\n  if (tarfile instanceof Blob) {\n    return (async () => {\n      const input = new Blob([tarfile]);\n      const noOfBlocks = input.size / 512;\n      const files: Readonly<TarFile<Blob>>[] = [];\n      {\n        let blockIdx = 0;\n        while (blockIdx < noOfBlocks) {\n          const block = input.slice(blockIdx * 512, (blockIdx + 1) * 512);\n          if (await isEmptyBlock(block)) break;\n          const file = parseTarHeader<Blob>(await block.arrayBuffer());\n          const fileBlocksCount = Math.ceil(file.size / 512);\n          file.contents = input\n            .slice((blockIdx + 1) * 512, (blockIdx + 1 + fileBlocksCount) * 512)\n            .slice(0, file.size);\n          files.push(Object.freeze(file!));\n          blockIdx += fileBlocksCount + 1;\n        }\n      }\n      return files;\n    })();\n  } else {\n    const input = new Uint8Array(tarfile);\n    const noOfBlocks = input.byteLength / 512;\n    const files: Readonly<TarFile<Uint8Array>>[] = [];\n    {\n      let blockIdx = 0;\n      while (blockIdx < noOfBlocks) {\n        const block = input.slice(blockIdx * 512, (blockIdx + 1) * 512);\n        if (isEmptyBlock(block)) break;\n        const file = parseTarHeader<Uint8Array>(block);\n        const fileBlocksCount = Math.ceil(file.size / 512);\n        file.contents = input\n          .slice((blockIdx + 1) * 512, (blockIdx + 1 + fileBlocksCount) * 512)\n          .slice(0, file.size);\n        files.push(Object.freeze(file!));\n        blockIdx += fileBlocksCount + 1;\n      }\n      return files;\n    }\n  }\n}\nfunction isEmptyBlock(block: Blob): Promise<boolean>;\nfunction isEmptyBlock(block: Uint8Array): boolean;\nfunction isEmptyBlock(block: Blob | Uint8Array) {\n  if (block instanceof Blob)\n    return block\n      .arrayBuffer()\n      .then((val) => new Uint8Array(val))\n      .then((buf) => buf.every((val) => val === 0));\n  return block.every((val) => val === 0);\n}\n// https://en.wikipedia.org/wiki/Tar_(computing)#Header\nexport const enum TarFileType {\n  NormalFile = 0,\n  HardLink = 1,\n  SymbolicLink = 2,\n  CharacterSpecial = 3,\n  BlockSpecial = 4,\n  Directory = 5,\n  NamedFIFOPipe = 6,\n  ContiguousFile = 7,\n  Vendor = \"vendor\",\n}\nexport class TarFile<T extends Blob | Uint8Array> {\n  name: string = \"\";\n  mode: number = 0;\n  uid: number = 0;\n  gid: number = 0;\n  size: number = 0;\n  mtime: Date = new Date(0);\n  type: TarFileType = TarFileType.NormalFile;\n  linkname: string = \"\";\n  contents?: T;\n  uname: string = \"\";\n  gname: string = \"\";\n  deviceMajor: number = 0;\n  deviceMinor: number = 0;\n  fileNamePrefix: string = \"\";\n}\nlet ustarWarned = false;\nfunction parseTarHeader<T extends Blob | Uint8Array>(header: ArrayBuffer) {\n  const file = new TarFile<T>();\n  file.name = readString(header, 0, 100);\n  file.mode = readOctal(header, 100, 8);\n  file.uid = readOctal(header, 108, 8);\n  file.gid = readOctal(header, 116, 8);\n  file.size = readOctal(header, 124, 12);\n  file.mtime = new Date(readOctal(header, 136, 12) * 1000);\n  const checksum = readString(header, 148, 8);\n  const ftype = readString(header, 156, 1);\n  if (ftype)\n    if (ftype.charCodeAt(0) >= 48 && ftype.charCodeAt(0) <= 57)\n      file.type = ftype.charCodeAt(0);\n    else file.type = TarFileType.Vendor;\n  else file.type = TarFileType.NormalFile;\n  file.linkname = readString(header, 157, 100);\n\n  const ustarIndicator = readString(header, 257, 6);\n  if (ustarIndicator === \"ustar\") {\n    file.uname = readString(header, 265, 32);\n    file.gname = readString(header, 297, 32);\n    file.deviceMajor = readOctal(header, 329, 8);\n    file.deviceMinor = readOctal(header, 337, 8);\n    file.fileNamePrefix = readString(header, 345, 155);\n  } else if (!ustarWarned) {\n    console.warn(\"No Ustar indicator detected in tar file\");\n    ustarWarned = true;\n  }\n  return file;\n}\nfunction readString(input: ArrayBufferLike, start: number = 0, size?: number) {\n  const decoder = new TextDecoder(\"ascii\");\n  let buf = new Uint8Array(input.slice(start, size ? start + size : undefined));\n  const nullIdx = buf.indexOf(0);\n  buf = buf.slice(0, nullIdx);\n  return decoder.decode(buf);\n}\nfunction readOctal(input: ArrayBufferLike, start: number = 0, end?: number) {\n  return parseInt(readString(input, start, end), 8);\n}\n"],"names":[],"version":3,"file":"index.d.ts.map"}