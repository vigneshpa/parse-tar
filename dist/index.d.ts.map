{"mappings":"AACA,OAAO,KAAK;IACV,UAAU,IAAI;IACd,QAAQ,IAAI;IACZ,YAAY,IAAI;IAChB,gBAAgB,IAAI;IACpB,YAAY,IAAI;IAChB,SAAS,IAAI;IACb,aAAa,IAAI;IACjB,cAAc,IAAI;IAClB,MAAM,WAAW;CAClB;AACD;IACE,IAAI,EAAE,MAAM,CAAM;IAClB,IAAI,EAAE,MAAM,CAAK;IACjB,GAAG,EAAE,MAAM,CAAK;IAChB,GAAG,EAAE,MAAM,CAAK;IAChB,IAAI,EAAE,MAAM,CAAK;IACjB,KAAK,EAAE,IAAI,CAAe;IAC1B,IAAI,EAAE,WAAW,CAA0B;IAC3C,QAAQ,EAAE,MAAM,CAAM;IACtB,QAAQ,EAAE,IAAI,CAAC;IACf,KAAK,EAAE,MAAM,CAAM;IACnB,KAAK,EAAE,MAAM,CAAM;IACnB,WAAW,EAAE,MAAM,CAAK;IACxB,WAAW,EAAE,MAAM,CAAK;IACxB,cAAc,EAAE,MAAM,CAAM;CAC7B;ACzBD,iCAAuC,OAAO,EAAE,IAAI,GAAG,IAAI,GAAG,WAAW,GAAG,eAAe,gCAgC1F","sources":["src/src/parseTarHeader.ts","src/src/parseTar.ts","src/parseTar.ts"],"sourcesContent":[null,null,"import parseTarHeader, { TarFile } from './parseTarHeader';\nexport { TarFile, TarFileType } from './parseTarHeader';\nexport default async function parseTar(tarfile: File | Blob | ArrayBuffer | ArrayBufferLike) {\n  const input = new Blob([tarfile]);\n  const blocks = getBlocks(input);\n  let files: Readonly<TarFile>[] = [];\n  {\n    let mode: 'header' | 'file' = 'header';\n    let file: TarFile;\n    let fileBlocks: Blob[] = [];\n    let fileBlocksCount = 0;\n    let fileIdx = 0;\n    for (const block of blocks) {\n      if (mode === 'file') {\n        if (fileIdx < fileBlocksCount) {\n          fileBlocks.push(block);\n          fileIdx++;\n        } else {\n          file!.contents = new Blob(fileBlocks).slice(0, file!.size);\n          files.push(Object.freeze(file!));\n          if (await isEmptyBlock(block)) break;\n          mode = 'header';\n        }\n      }\n      if (mode === 'header') {\n        file = await parseTarHeader(block);\n        mode = 'file';\n        fileBlocks = [];\n        fileBlocksCount = Math.ceil(file.size / 512);\n        fileIdx = 0;\n      }\n    }\n  }\n  return files;\n}\nfunction getBlocks(input: Blob, size = 512) {\n  const noOfBlocks = Math.floor(input.size / size);\n  const ret: Blob[] = [];\n  for (let i = 0; i < noOfBlocks; i++) {\n    ret.push(input.slice(i * size, (i + 1) * size));\n  }\n  return ret;\n}\n\nasync function isEmptyBlock(block: Blob) {\n  const buf = new Uint8Array(await block.arrayBuffer());\n  return buf.every(val => val === 0);\n}\n"],"names":[],"version":3,"file":"index.d.ts.map"}